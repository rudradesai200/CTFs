#### Solution

- First, I ran the executable thinking it may give some info, but nothing got printed and it looked like it was waiting for connection or something.
- Then, because we were only given the executable, I tried to statically analyze it on Ghidra.
- I ran Ghidra and extracted the main function in a new file source.c
- I tried to understand the code and I figured out these things
  - This was a simple socket program
  - After figuring the socket connections part, we can see that it was simply using string manip to compare the request with some strings.
  - So, decoding the if-else part, I figured out that if it didn't received a GET HTTP request, it will print some fixed garbage response, which is of no use.
  - Then, if it is a GET HTTP request, It checked for params, and replaced "&|>$<" with spaces.
  - So, if my request is of this form , /echo?message it will be translated to a string, "echo message". OR if /?ls$-la will be translated to "ls -la"
  - This string was then passed to popen(). Checking out the manual page of popen(), we can figure out that the first argument of popen() is a command to the terminal and popen() will open a pipe to the result on that terminal.
  - So, basically whatever we give in the request was converted to a command and the output was passed back as the response.
  - But, there were 2 problems to this.
    - The response was white space sensitive, so if the result contained any \n, it was terminated there.
    - The length was determined by the length of request
  - Hence, to get the flag, I made the following 2 GET requests
    - `/?ls$-la$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$;` ($s are to increase length)
    - `/?cat$flag.txt$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$;`
  - It gave me the flag, UMASS{f^gJkmvYq}
  - Challenge solved.
